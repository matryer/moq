package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/matryer/moq/pkg/moq"
)

var Version string = "dev"

type userFlags struct {
	outFile    string
	pkgName    string
	formatter  string
	stubImpl   bool
	skipEnsure bool
	withResets bool
	remove     bool
	args       []string
}

func main() {
	var flags userFlags
	flag.StringVar(&flags.outFile, "out", "", "output file (default stdout)")
	flag.StringVar(&flags.pkgName, "pkg", "", "package name (default will infer)")
	flag.StringVar(&flags.formatter, "fmt", "", "go pretty-printer: gofmt, goimports or noop (default gofmt)")
	flag.BoolVar(&flags.stubImpl, "stub", false,
		"return zero values when no mock implementation is provided, do not panic")
	printVersion := flag.Bool("version", false, "show the version for moq")
	flag.BoolVar(&flags.skipEnsure, "skip-ensure", false,
		"suppress mock implementation check, avoid import cycle if mocks generated outside of the tested package")
	flag.BoolVar(&flags.remove, "rm", false, "first remove output file, if it exists")
	flag.BoolVar(&flags.withResets, "with-resets", false,
		"generate functions to facilitate resetting calls made to a mock")

	flag.Usage = func() {
		fmt.Println(`moq [flags] source-dir interface [interface2 [interface3 [...]]]`)
		flag.PrintDefaults()
		fmt.Println(`Specifying an alias for the mock is also supported with the format 'interface:alias'`)
		fmt.Println(`Ex: moq -pkg different . MyInterface:MyMock`)
	}

	flag.Parse()
	flags.args = flag.Args()

	if *printVersion {
		fmt.Printf("moq version %s\n", Version)
		os.Exit(0)
	}

	if err := run(flags); err != nil {
		fmt.Fprintln(os.Stderr, err)
		flag.Usage()
		os.Exit(1)
	}
}

func run(flags userFlags) error {
	var (
		buf    bytes.Buffer
		out    io.Writer = os.Stdout
		srcDir string
	)

	if NotEnoughArguments(flags) {
		return errors.New("not enough arguments")
	}

	if ShouldRemoveFile(flags) {
		if err := RemoveFile(flags.outFile); err != nil && !os.IsNotExist(err) {
			return err
		}
	}

	if ShouldWriteToFile(flags) {
		out = &buf
	}

	srcDir, cleanUp, err := getSourceDirectory(flags)
	if err != nil {
		return err
	}
	defer cleanUp()

	m, err := CreateMoq(flags, srcDir)
	if err != nil {
		return err
	}

	if err := m.Mock(out, flags.args[1:]...); err != nil {
		return err
	}

	if flags.outFile == "" {
		return nil
	}

	if err := CreateOutputFile(flags.outFile, buf.Bytes()); err != nil {
		return err
	}

	return nil
}

func getSourceDirectory(flags userFlags) (string, func(), error) {
	if DirectoryExists(flags.args[0]) {
		return flags.args[0], func() {}, nil
	}

	cmd := exec.Command("go", "list", flag.Args()[0])
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", func() {}, fmt.Errorf("%s", output)
	}

	pwd, err := os.Getwd()
	if err != nil {
		return "", func() {}, err
	}

	tempDir, err := os.MkdirTemp(pwd, "moq_force_local_interface_mode_")
	if err != nil {
		return "", func() {}, err
	}

	if err := GenerateMoqForceLocalInterface(flags, tempDir); err != nil {
		return "", func() {}, err
	}

	return tempDir, func() { os.RemoveAll(tempDir) }, nil

}

func NotEnoughArguments(flags userFlags) bool {
	return len(flags.args) < 2
}

func ShouldRemoveFile(flags userFlags) bool {
	return flags.remove && flags.outFile != ""
}

func RemoveFile(filePath string) error {
	return os.Remove(filePath)
}

func ShouldWriteToFile(flags userFlags) bool {
	return flags.outFile != ""
}

func DirectoryExists(directoryPath string) bool {
	_, err := os.Stat(directoryPath)
	return err == nil
}

func GenerateMoqForceLocalInterface(flags userFlags, tempDir string) error {
	tmpl, err := template.New("force_local_interface").Parse(moqForceLocalInterface)
	if err != nil {
		return err
	}

	var buf bytes.Buffer

	err = tmpl.Execute(&buf, map[string]interface{}{
		"SrcPkgQualifier": filepath.Base(flags.args[0]),
		"Import":          flags.args[0],
		"InterfaceName":   flags.args[1],
	})
	if err != nil {
		return err
	}

	return os.WriteFile(filepath.Join(tempDir, "moq_force_local_interface.go"), buf.Bytes(), 0600)
}

func CreateMoq(flags userFlags, srcDir string) (*moq.Mocker, error) {
	return moq.New(moq.Config{
		SrcDir:     srcDir,
		PkgName:    flags.pkgName,
		Formatter:  flags.formatter,
		StubImpl:   flags.stubImpl,
		SkipEnsure: flags.skipEnsure,
		WithResets: flags.withResets,
	})
}

func CreateOutputFile(filePath string, data []byte) error {
	if err := os.MkdirAll(filepath.Dir(filePath), 0750); err != nil {
		return err
	}
	return os.WriteFile(filePath, data, 0600)
}

const moqForceLocalInterface = `// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package {{.SrcPkgQualifier}}

import "{{.Import}}"

type {{.InterfaceName}} {{$.SrcPkgQualifier}}.{{.InterfaceName}}
`
