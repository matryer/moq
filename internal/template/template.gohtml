// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
)

{{range $i, $mock := .Mocks -}}

	{{- if not $.SkipEnsure -}}
		// Ensure, that {{.MockName}} does implement {{$.SrcPkgQualifier}}{{.InterfaceName}}.
		// If this is not the case, regenerate this file with moq.
		var _ {{$.SrcPkgQualifier}}{{.InterfaceName -}}
		{{- if .TypeParams }}[
		{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}
		]
		{{- end }} = &{{.MockName}}
		{{- if .TypeParams }}[
		{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}
		]
		{{- end -}}
		{}
	{{- end}}

	// {{.MockName}} is a mock implementation of {{$.SrcPkgQualifier}}{{.InterfaceName}}.
	//
	//	func TestSomethingThatUses{{.InterfaceName}}(t *testing.T) {
	//
	//		// make and configure a mocked {{$.SrcPkgQualifier}}{{.InterfaceName}}
	//		mocked{{.InterfaceName}} := &{{.MockName}}{
	{{- range .Methods}}
		//			{{.Name}}Func: func({{.ArgList}}) {{.ReturnArgTypeList}} {
		//				panic("mock out the {{.Name}} method")
		//			},
	{{- end}}
	//		}
	//
	//		// use mocked{{.InterfaceName}} in code that requires {{$.SrcPkgQualifier}}{{.InterfaceName}}
	//		// and then make assertions.
	//
	//	}
	{{/* Begin of main type struct */}}
	type {{.MockName}}
	{{- if .TypeParams -}}
		[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end}}{{$param.Name | Exported}} {{$param.TypeString}}
		{{- end -}}]
	{{- end }} struct {
	{{- range .Methods}}
		// {{.Name}}Func mocks the {{.Name}} method.
		{{.Name}}Func func({{.ArgList}}) {{.ReturnArgTypeList}}
	{{end}}
	// calls tracks calls to the methods.
	calls struct {
	{{- range .Methods}}
		// {{.Name}} holds details about calls to the {{.Name}} method.
		{{.Name}} []{{$mock.MockName}}{{.Name}}Calls
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end }}
	{{- end}}
	}
	{{- range .Methods}}
		lock{{.Name}} {{$.Imports | SyncPkgQualifier}}.RWMutex
	{{- end}}
	}
	{{/* End of main type struct */}}
	{{/* Begin of calls type struct */}}
	{{- range .Methods}}
		// {{$mock.MockName}}{{.Name}}Calls holds details about calls to the {{.Name}} method.
		type {{$mock.MockName}}{{.Name}}Calls
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}} {{$param.TypeString}}
			{{- end -}}]
		{{- end }} struct  {
		{{- range .Params}}
			// {{.Name | Exported}} is the {{.Name}} argument value.
			{{.Name | Exported}} {{.TypeString}}
		{{- end}}
		}
	{{- end}}
	{{/* End of main type */}}

	{{/* Begin of functions */}}
	{{range .Methods}}
		// {{.Name}} calls {{.Name}}Func.
		func (mock *{{$mock.MockName}}
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end -}}
		) {{.Name}}({{.ArgList}}) {{.ReturnArgTypeList}} {
		{{- if not $.StubImpl}}
			if mock.{{.Name}}Func == nil {
			panic("{{$mock.MockName}}.{{.Name}}Func: method is nil but {{$mock.InterfaceName}}.{{.Name}} was just called")
			}
		{{- end}}
		callInfo := {{$mock.MockName}}{{.Name}}Calls
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end }}  {
		{{- range .Params}}
			{{.Name | Exported}}: {{.Name}},
		{{- end}}
		}
		mock.lock{{.Name}}.Lock()
		mock.calls.{{.Name}} = append(mock.calls.{{.Name}}, callInfo)
		mock.lock{{.Name}}.Unlock()
		{{- if .Returns}}
			{{- if $.StubImpl}}
				if mock.{{.Name}}Func == nil {
				var (
				{{- range .Returns}}
					{{.Name}} {{.TypeString}}
				{{- end}}
				)
				return {{.ReturnArgNameList}}
				}
			{{- end}}
			return mock.{{.Name}}Func({{.ArgCallList}})
		{{- else}}
			{{- if $.StubImpl}}
				if mock.{{.Name}}Func == nil {
				return
				}
			{{- end}}
			mock.{{.Name}}Func({{.ArgCallList}})
		{{- end}}
		}

		// {{.Name}}Calls gets all the calls that were made to {{.Name}}.
		// Check the length with:
		//
		//	len(mocked{{$mock.InterfaceName}}.{{.Name}}Calls())
		func (mock *{{$mock.MockName}}
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end -}}
		) {{.Name}}Calls() []{{$mock.MockName}}{{.Name}}Calls
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end }}  {
		var calls []{{$mock.MockName}}{{.Name}}Calls
		{{- if $mock.TypeParams -}}
			[{{- range $index, $param := $mock.TypeParams}}
				{{- if $index}}, {{end}}{{$param.Name | Exported}}
			{{- end -}}]
		{{- end }}
		mock.lock{{.Name}}.RLock()
		calls = mock.calls.{{.Name}}
		mock.lock{{.Name}}.RUnlock()
		return calls
		}
		{{- if $.WithResets}}
			// Reset{{.Name}}Calls reset all the calls that were made to {{.Name}}.
			func (mock *{{$mock.MockName}}) Reset{{.Name}}Calls() {
			mock.lock{{.Name}}.Lock()
			mock.calls.{{.Name}} = nil
			mock.lock{{.Name}}.Unlock()
			}
		{{end}}
	{{end -}}
	{{- if $.WithResets}}
		// ResetCalls reset all the calls that were made to all mocked methods.
		func (mock *{{$mock.MockName}}) ResetCalls() {
		{{- range .Methods}}
			mock.lock{{.Name}}.Lock()
			mock.calls.{{.Name}} = nil
			mock.lock{{.Name}}.Unlock()
		{{end -}}
		}
	{{end -}}
	{{/* End of functions */}}
{{end -}}