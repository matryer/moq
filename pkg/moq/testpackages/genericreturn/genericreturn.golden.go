// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package genericreturn

import (
	"github.com/matryer/moq/pkg/moq/testpackages/genericreturn/otherpackage"
	"sync"
)

// Ensure, that IFooBarMock does implement IFooBar.
// If this is not the case, regenerate this file with moq.
var _ IFooBar = &IFooBarMock{}

// IFooBarMock is a mock implementation of IFooBar.
//
//	func TestSomethingThatUsesIFooBar(t *testing.T) {
//
//		// make and configure a mocked IFooBar
//		mockedIFooBar := &IFooBarMock{
//			FoobarFunc: func() GenericBar[otherpackage.Foo] {
//				panic("mock out the Foobar method")
//			},
//		}
//
//		// use mockedIFooBar in code that requires IFooBar
//		// and then make assertions.
//
//	}

type IFooBarMock struct {
	// FoobarFunc mocks the Foobar method.
	FoobarFunc func() GenericBar[otherpackage.Foo]

	// calls tracks calls to the methods.
	calls struct {
		// Foobar holds details about calls to the Foobar method.
		Foobar []IFooBarMockFoobarCalls
	}
	lockFoobar sync.RWMutex
}

// IFooBarMockFoobarCalls holds details about calls to the Foobar method.
type IFooBarMockFoobarCalls struct {
}

// Foobar calls FoobarFunc.
func (mock *IFooBarMock) Foobar() GenericBar[otherpackage.Foo] {
	if mock.FoobarFunc == nil {
		panic("IFooBarMock.FoobarFunc: method is nil but IFooBar.Foobar was just called")
	}
	callInfo := IFooBarMockFoobarCalls{}
	mock.lockFoobar.Lock()
	mock.calls.Foobar = append(mock.calls.Foobar, callInfo)
	mock.lockFoobar.Unlock()
	return mock.FoobarFunc()
}

// FoobarCalls gets all the calls that were made to Foobar.
// Check the length with:
//
//	len(mockedIFooBar.FoobarCalls())
func (mock *IFooBarMock) FoobarCalls() []IFooBarMockFoobarCalls {
	var calls []IFooBarMockFoobarCalls
	mock.lockFoobar.RLock()
	calls = mock.calls.Foobar
	mock.lockFoobar.RUnlock()
	return calls
}
