// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package paramconflict

import (
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
// 	func TestSomethingThatUsesInterface(t *testing.T) {
//
// 		// make and configure a mocked Interface
// 		mockedInterface := &InterfaceMock{
// 			MethodFunc: func(s1 string, b1 bool, s2 string, b2 bool, n1 int, n2 int32, n3 int64, f1 float32, f2 float64)  {
// 				panic("mock out the Method method")
// 			},
// 		}
//
// 		// use mockedInterface in code that requires Interface
// 		// and then make assertions.
//
// 	}
type InterfaceMock struct {
	// MethodFunc mocks the Method method.
	MethodFunc func(s1 string, b1 bool, s2 string, b2 bool, n1 int, n2 int32, n3 int64, f1 float32, f2 float64)

	// calls tracks calls to the methods.
	calls struct {
		// Method holds details about calls to the Method method.
		Method []struct {
			// S1 is the s1 argument value.
			S1 string
			// B1 is the b1 argument value.
			B1 bool
			// S2 is the s2 argument value.
			S2 string
			// B2 is the b2 argument value.
			B2 bool
			// N1 is the n1 argument value.
			N1 int
			// N2 is the n2 argument value.
			N2 int32
			// N3 is the n3 argument value.
			N3 int64
			// F1 is the f1 argument value.
			F1 float32
			// F2 is the f2 argument value.
			F2 float64
		}
	}
	lockMethod sync.RWMutex
}

// Method calls MethodFunc.
func (mock *InterfaceMock) Method(s1 string, b1 bool, s2 string, b2 bool, n1 int, n2 int32, n3 int64, f1 float32, f2 float64) {
	if mock.MethodFunc == nil {
		panic("InterfaceMock.MethodFunc: method is nil but Interface.Method was just called")
	}
	callInfo := struct {
		S1 string
		B1 bool
		S2 string
		B2 bool
		N1 int
		N2 int32
		N3 int64
		F1 float32
		F2 float64
	}{
		S1: s1,
		B1: b1,
		S2: s2,
		B2: b2,
		N1: n1,
		N2: n2,
		N3: n3,
		F1: f1,
		F2: f2,
	}
	mock.lockMethod.Lock()
	mock.calls.Method = append(mock.calls.Method, callInfo)
	mock.lockMethod.Unlock()
	mock.MethodFunc(s1, b1, s2, b2, n1, n2, n3, f1, f2)
}

// MethodCalls gets all the calls that were made to Method.
// Check the length with:
//     len(mockedInterface.MethodCalls())
func (mock *InterfaceMock) MethodCalls() []struct {
	S1 string
	B1 bool
	S2 string
	B2 bool
	N1 int
	N2 int32
	N3 int64
	F1 float32
	F2 float64
} {
	var calls []struct {
		S1 string
		B1 bool
		S2 string
		B2 bool
		N1 int
		N2 int32
		N3 int64
		F1 float32
		F2 float64
	}
	mock.lockMethod.RLock()
	calls = mock.calls.Method
	mock.lockMethod.RUnlock()
	return calls
}
