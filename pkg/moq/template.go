package moq

// moqImports are the imports all moq files get.
var moqImports = []string{}

// moqTemplate is the template for mocked code.
// language=GoTemplate
var moqTemplate = `// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package {{.PackageName}}
{{- $sourcePackagePrefix := .SourcePackagePrefix}}
{{- $stubImpl := .StubImpl}}
{{- $skipEnsure := .SkipEnsure}}

import (
{{- range .Imports }}
	"{{.}}"
{{- end }}
)

{{ range $i, $obj := .Objects -}}

{{- if not $skipEnsure -}}
// Ensure, that {{.MockName}} does implement {{$sourcePackagePrefix}}{{.InterfaceName}}.
// If this is not the case, regenerate this file with moq.
var _ {{$sourcePackagePrefix}}{{.InterfaceName}} = &{{.MockName}}{}
{{- end }}

// {{.MockName}} is a mock implementation of {{$sourcePackagePrefix}}{{.InterfaceName}}.
//
//     func TestSomethingThatUses{{.InterfaceName}}(t *testing.T) {
//
//         // make and configure a mocked {{$sourcePackagePrefix}}{{.InterfaceName}}
//         mocked{{.InterfaceName}} := &{{.MockName}}{ {{ range .Methods }}
//             {{.Name}}Func: func({{ .Arglist }}) {{.ReturnArgTypeList}} {
// 	               panic("mock out the {{.Name}} method")
//             },{{- end }}
//         }
//
//         // use mocked{{.InterfaceName}} in code that requires {{$sourcePackagePrefix}}{{.InterfaceName}}
//         // and then make assertions.
//
//     }
type {{.MockName}} struct {
{{- range .Methods }}
	// {{.Name}}Func mocks the {{.Name}} method.
	{{.Name}}Func func({{ .Arglist }}) {{.ReturnArgTypeList}}
{{ end }}
	// calls tracks calls to the methods.
	calls struct {
{{- range .Methods }}
		// {{ .Name }} holds details about calls to the {{.Name}} method.
		{{ .Name }} []struct {
			{{- range .Params }}
			// {{ .Name | Exported }} is the {{ .Name }} argument value.
			{{ .Name | Exported }} {{ .Type }}
			{{- end }}
		}
{{- end }}
	}
{{- range .Methods }}
	lock{{.Name}} sync.RWMutex
{{- end }}
}
{{ range .Methods }}
// {{.Name}} calls {{.Name}}Func.
func (mock *{{$obj.MockName}}) {{.Name}}({{.Arglist}}) {{.ReturnArgTypeList}} {
{{- if not $stubImpl }}
	if mock.{{.Name}}Func == nil {
		panic("{{$obj.MockName}}.{{.Name}}Func: method is nil but {{$obj.InterfaceName}}.{{.Name}} was just called")
	}
{{- end }}
	callInfo := struct {
		{{- range .Params }}
		{{ .Name | Exported }} {{ .Type }}
		{{- end }}
	}{
		{{- range .Params }}
		{{ .Name | Exported }}: {{ .Name }},
		{{- end }}
	}
	mock.lock{{.Name}}.Lock()
	mock.calls.{{.Name}} = append(mock.calls.{{.Name}}, callInfo)
	mock.lock{{.Name}}.Unlock()
{{- if .Returns }}
	{{- if $stubImpl }}
	if mock.{{.Name}}Func == nil {
		var (
		{{- range .Returns }}
			{{.Name}} {{.Type}}
		{{- end }}
		)
		return {{.ReturnArgNameList}}
	}
	{{- end }}
	return mock.{{.Name}}Func({{.ArgCallList}})
{{- else }}
	{{- if $stubImpl }}
	if mock.{{.Name}}Func == nil {
		return
	}
	{{- end }}
	mock.{{.Name}}Func({{.ArgCallList}})
{{- end }}
}

// {{.Name}}Calls gets all the calls that were made to {{.Name}}.
// Check the length with:
//     len(mocked{{$obj.InterfaceName}}.{{.Name}}Calls())
func (mock *{{$obj.MockName}}) {{.Name}}Calls() []struct {
		{{- range .Params }}
		{{ .Name | Exported }} {{ .Type }}
		{{- end }}
	} {
	var calls []struct {
		{{- range .Params }}
		{{ .Name | Exported }} {{ .Type }}
		{{- end }}
	}
	mock.lock{{.Name}}.RLock()
	calls = mock.calls.{{.Name}}
	mock.lock{{.Name}}.RUnlock()
	return calls
}
{{ end -}}
{{ end -}}`
